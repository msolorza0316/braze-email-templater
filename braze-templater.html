<script>
(function(){
  // Run after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupFix, { once: true });
  } else {
    setupFix();
  }

  function setupFix(){
    const preview = document.getElementById('preview');
    if (!preview) return;

    // Replace buttons with clean clones to drop any older listeners
    function resetButton(id){
      const btn = document.getElementById(id);
      if (!btn) return null;
      const clone = btn.cloneNode(true);
      btn.replaceWith(clone);
      return clone;
    }

    const addPrimary   = resetButton('add-primary');
    const addSecondary = resetButton('add-secondary');
    const addPartner   = resetButton('add-partner');

    const badge = document.getElementById('be-count');
    function updateBadge(){
      if (badge) badge.textContent = (preview.querySelectorAll('.be-block').length) + ' blocks';
    }
    updateBadge();

    const isLocked = b => (b?.dataset?.type === 'locked');

    function area(el){
      const r = el.getBoundingClientRect();
      return (r.width || 1) * (r.height || 1);
    }

    function tableCount(el){
      // prefer a direct table (common for unit blocks)
      const direct = el.querySelectorAll(':scope > table').length;
      return direct || el.querySelectorAll('table').length;
    }

    function pickTemplate(type){
      const all = Array.from(preview.querySelectorAll('.be-block')).filter(Boolean);
      const candidates = all.filter(b => b.dataset && b.dataset.type === type && !isLocked(b));
      if (!candidates.length) return null;

      const scored = candidates.map(el => ({
        el, tables: tableCount(el), area: area(el)
      }));

      const singles = scored.filter(s => s.tables === 1);
      const pool = singles.length ? singles : scored;
      const chosen = pool.sort((a,b) => a.area - b.area)[0].el;

      // Deep clone + sanitize duplicate IDs
      const clone = chosen.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));

      // Optional: relabel copy for clarity
      const labelSpan = clone.querySelector('.be-label span');
      const nice = (chosen.dataset && chosen.dataset.label) ? chosen.dataset.label
                 : (type.charAt(0).toUpperCase() + type.slice(1));
      if (labelSpan) labelSpan.textContent = nice + ' (copy)';

      return clone;
    }

    function appendClone(type){
      const node = pickTemplate(type);
      if (!node) {
        // Fallback: take the smallest non-locked block if type not found
        const pool = Array.from(preview.querySelectorAll('.be-block')).filter(b => !isLocked(b));
        if (!pool.length) return;
        const chosen = pool.sort((a,b) => area(a) - area(b))[0];
        const fallback = chosen.cloneNode(true);
        fallback.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
        preview.appendChild(fallback);
      } else {
        preview.appendChild(node);
      }
      updateBadge();
    }

    if (addPrimary)   addPrimary.addEventListener('click', function(e){ e.preventDefault(); appendClone('primary'); }, { passive:false });
    if (addSecondary) addSecondary.addEventListener('click', function(e){ e.preventDefault(); appendClone('secondary'); }, { passive:false });
    if (addPartner)   addPartner.addEventListener('click', function(e){
      e.preventDefault();
      const header = pickTemplate('partner-header');
      const card   = pickTemplate('partner-card');
      if (header) preview.appendChild(header);
      if (card)   preview.appendChild(card);
      updateBadge();
    }, { passive:false });
  }
})();
</script>
<script>
(function(){
  // Enhance the safe-clone behavior: Primary must insert a white card like "Story 1 card"
  function ready(fn){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true }); else fn(); }
  ready(function(){
    const preview = document.getElementById('preview');
    const addPrimary = document.getElementById('add-primary');
    if (!preview || !addPrimary) return;

    // Overwrite any existing listener by replacing the node
    const btn = addPrimary.cloneNode(true);
    addPrimary.replaceWith(btn);

    function isLocked(b){ return b?.dataset?.type === 'locked'; }

    function area(el){
      const r = el.getBoundingClientRect();
      return (r.width || 1) * (r.height || 1);
    }

    function tableCount(el){
      const direct = el.querySelectorAll(':scope > table').length;
      return direct || el.querySelectorAll('table').length;
    }

    function hasWhiteBg(el){
      // Look for inline styles or attributes indicating white background
      const w = /(#fff(fff)?\\b|\\bwhite\\b)/i;
      if (el.getAttribute('bgcolor') && w.test(el.getAttribute('bgcolor'))) return true;
      if (el.hasAttribute('style') && w.test(el.getAttribute('style'))) return true;
      // Check tables within
      const t = el.querySelector('table');
      if (t){
        if (t.getAttribute('bgcolor') && w.test(t.getAttribute('bgcolor'))) return true;
        if (t.hasAttribute('style') && w.test(t.getAttribute('style'))) return true;
      }
      return false;
    }

    function textIncludes(el, s){
      return (el.textContent || '').toLowerCase().includes(s.toLowerCase());
    }

    function findStory1Primary(){
      const primaries = Array.from(preview.querySelectorAll('.be-block')).filter(b => b.dataset?.type === 'primary' && !isLocked(b));
      if (!primaries.length) return null;

      // 1) Exact label match in data-label or visible label
      let exact = primaries.find(b => /story\\s*1/i.test(b.dataset?.label || ''));
      if (!exact){
        exact = primaries.find(b => /story\\s*1/i.test((b.querySelector('.be-label')?.textContent)||''));
      }
      if (exact) return exact;

      // 2) Prefer white background + single table
      const scored = primaries.map(el => ({
        el,
        white: hasWhiteBg(el) ? 1 : 0,
        tables: tableCount(el),
        area: area(el),
        storyHint: (/(story|card)/i.test(el.dataset?.label || '') || /(story|card)/i.test((el.querySelector('.be-label')?.textContent)||'')) ? 1 : 0,
      }));

      scored.sort((a,b)=>{
        // Prefer white, then story hint, then single-table, then smallest area
        return (b.white - a.white) || (b.storyHint - a.storyHint) || ((a.tables===1)-(b.tables===1)) || (a.area - b.area);
      });

      return scored[0]?.el || null;
    }

    function cloneSanitized(node){
      const clone = node.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
      const labelSpan = clone.querySelector('.be-label span');
      const nice = (node.dataset && node.dataset.label) ? node.dataset.label : 'Primary';
      if (labelSpan) labelSpan.textContent = nice + ' (copy)';
      return clone;
    }

    btn.addEventListener('click', function(e){
      e.preventDefault();
      let chosen = findStory1Primary();
      if (!chosen){
        // Fallback: smallest non-locked primary; then any smallest non-locked block
        const primaries = Array.from(preview.querySelectorAll('.be-block')).filter(b => b.dataset?.type === 'primary' && !isLocked(b));
        if (primaries.length){
          primaries.sort((a,b)=> area(a) - area(b));
          chosen = primaries[0];
        } else {
          const pool = Array.from(preview.querySelectorAll('.be-block')).filter(b => !isLocked(b));
          if (!pool.length) return;
          pool.sort((a,b)=> area(a) - area(b));
          chosen = pool[0];
        }
      }
      const copy = cloneSanitized(chosen);
      preview.appendChild(copy);
      const badge = document.getElementById('be-count');
      if (badge) badge.textContent = (preview.querySelectorAll('.be-block').length) + ' blocks';
    }, { passive:false });
  });
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once:true }); else fn(); }
  ready(function(){
    const preview = document.getElementById('preview');
    if (!preview) return;

    // Replace buttons to drop previous listeners
    function reset(id){
      const el = document.getElementById(id);
      if (!el) return null;
      const clone = el.cloneNode(true);
      el.replaceWith(clone);
      return clone;
    }
    const addPrimary   = reset('add-primary');
    const addSecondary = reset('add-secondary');
    const addPartner   = reset('add-partner');
    const badge        = document.getElementById('be-count');

    function updateBadge(){
      if (badge) badge.textContent = (preview.querySelectorAll('.be-block').length) + ' blocks';
    }

    function blocks(){ return Array.from(preview.querySelectorAll('.be-block')); }
    function isLocked(b){ return b?.dataset?.type === 'locked'; }
    function area(el){ const r=el.getBoundingClientRect(); return (r.width||1)*(r.height||1); }
    function tableCount(el){ const direct = el.querySelectorAll(':scope > table').length; return direct || el.querySelectorAll('table').length; }
    function hasWhiteBg(el){
      const w=/(#fff(fff)?\b|\bwhite\b)/i;
      if (el.getAttribute('bgcolor') && w.test(el.getAttribute('bgcolor'))) return true;
      if (el.hasAttribute('style') && w.test(el.getAttribute('style'))) return true;
      const t=el.querySelector('table');
      if (t){
        if (t.getAttribute('bgcolor') && w.test(t.getAttribute('bgcolor'))) return true;
        if (t.hasAttribute('style') && w.test(t.getAttribute('style'))) return true;
      }
      return false;
    }

    function pickPrimary(){
      const primaries = blocks().filter(b => b.dataset?.type === 'primary' && !isLocked(b));
      if (!primaries.length) return null;
      let exact = primaries.find(b => /story\s*1/i.test(b.dataset?.label||''))
             ||  primaries.find(b => /story\s*1/i.test((b.querySelector('.be-label')?.textContent)||''));
      if (exact) return exact;
      const scored = primaries.map(el => ({
        el, white: hasWhiteBg(el) ? 1 : 0, tables: tableCount(el), area: area(el),
        hint: (/(story|card)/i.test(el.dataset?.label||'') || /(story|card)/i.test((el.querySelector('.be-label')?.textContent)||'')) ? 1 : 0
      }));
      scored.sort((a,b) => (b.white-a.white) || (b.hint-a.hint) || ((a.tables===1)-(b.tables===1)) || (a.area-b.area));
      return scored[0]?.el || null;
    }

    function pickByType(type){
      // Generic picker for non-primary
      const list = blocks().filter(b => b.dataset?.type === type && !isLocked(b));
      if (!list.length) return null;
      // Prefer single table, then smallest
      const scored = list.map(el => ({ el, tables: tableCount(el), area: area(el) }));
      scored.sort((a,b) => ((a.tables===1)-(b.tables===1)) || (a.area - b.area));
      return scored[0].el;
    }

    function cloneSanitized(node, labelFallback){
      const clone = node.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
      const labelSpan = clone.querySelector('.be-label span');
      const nice = (node.dataset && node.dataset.label) ? node.dataset.label : labelFallback;
      if (labelSpan && nice) labelSpan.textContent = nice + ' (copy)';
      return clone;
    }

    function insertSecondToLast(node){
      const list = blocks();
      if (!list.length){
        preview.appendChild(node);
        return;
      }
      // second-to-last means index length-1
      const idx = Math.max(0, list.length - 1);
      const ref = list[idx];
      ref.before(node);
    }

    // Wire buttons
    if (addPrimary) addPrimary.addEventListener('click', function(e){
      e.preventDefault();
      let chosen = pickPrimary();
      if (!chosen){
        // fallback: smallest non-locked block
        const pool = blocks().filter(b => !isLocked(b));
        if (!pool.length) return;
        pool.sort((a,b)=> area(a) - area(b));
        chosen = pool[0];
      }
      const copy = cloneSanitized(chosen, 'Primary');
      insertSecondToLast(copy);
      updateBadge();
    }, { passive:false });

    if (addSecondary) addSecondary.addEventListener('click', function(e){
      e.preventDefault();
      let chosen = pickByType('secondary');
      if (!chosen){
        const pool = blocks().filter(b => !isLocked(b));
        if (!pool.length) return;
        pool.sort((a,b)=> area(a) - area(b));
        chosen = pool[0];
      }
      const copy = cloneSanitized(chosen, 'Secondary');
      insertSecondToLast(copy);
      updateBadge();
    }, { passive:false });

    if (addPartner) addPartner.addEventListener('click', function(e){
      e.preventDefault();
      const header = pickByType('partner-header');
      const card   = pickByType('partner-card');
      if (header){ insertSecondToLast(cloneSanitized(header, 'Partner header')); }
      if (card){   insertSecondToLast(cloneSanitized(card, 'Partner card')); }
      updateBadge();
    }, { passive:false });

    updateBadge();
  });
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once:true }); else fn(); }
  ready(function(){
    const preview = document.getElementById('preview');
    if (!preview) return;

    function blocks(){ return Array.from(preview.querySelectorAll('.be-block')); }

    function insertThirdToLast(node){
      const list = blocks();
      if (!list.length){
        preview.appendChild(node);
        return;
      }
      const idx = Math.max(0, list.length - 2);
      const ref = list[idx];
      ref.before(node);
    }

    // Helpers
    function isLocked(b){ return b?.dataset?.type === 'locked'; }
    function area(el){ const r=el.getBoundingClientRect(); return (r.width||1)*(r.height||1); }
    function tableCount(el){ const direct=el.querySelectorAll(':scope > table').length; return direct || el.querySelectorAll('table').length; }
    function hasWhiteBg(el){ const w=/(#fff(fff)?\b|\bwhite\b)/i;
      if(el.getAttribute('bgcolor')&&w.test(el.getAttribute('bgcolor'))) return true;
      if(el.hasAttribute('style')&&w.test(el.getAttribute('style'))) return true;
      const t=el.querySelector('table');
      if(t){ if(t.getAttribute('bgcolor')&&w.test(t.getAttribute('bgcolor'))) return true;
        if(t.hasAttribute('style')&&w.test(t.getAttribute('style'))) return true; }
      return false; }

    function pickPrimary(){
      const primaries=blocks().filter(b=>b.dataset?.type==='primary' && !isLocked(b));
      if(!primaries.length) return null;
      let exact=primaries.find(b=>/story\s*1/i.test(b.dataset?.label||''))
              ||primaries.find(b=>/story\s*1/i.test((b.querySelector('.be-label')?.textContent)||''));
      if(exact) return exact;
      const scored=primaries.map(el=>({
        el,white:hasWhiteBg(el)?1:0,tables:tableCount(el),area:area(el),
        hint:(/(story|card)/i.test(el.dataset?.label||'')||/(story|card)/i.test((el.querySelector('.be-label')?.textContent)||''))?1:0
      }));
      scored.sort((a,b)=>(b.white-a.white)||(b.hint-a.hint)||((a.tables===1)-(b.tables===1))||(a.area-b.area));
      return scored[0]?.el||null;
    }

    function pickByType(type){
      const list=blocks().filter(b=>b.dataset?.type===type && !isLocked(b));
      if(!list.length) return null;
      const scored=list.map(el=>({el,tables:tableCount(el),area:area(el)}));
      scored.sort((a,b)=>((a.tables===1)-(b.tables===1))||(a.area-b.area));
      return scored[0].el;
    }

    function cloneSanitized(node,labelFallback){
      const clone=node.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n=>n.removeAttribute('id'));
      const labelSpan=clone.querySelector('.be-label span');
      const nice=(node.dataset&&node.dataset.label)?node.dataset.label:labelFallback;
      if(labelSpan&&nice) labelSpan.textContent=nice+' (copy)';
      return clone;
    }

    function reset(id){
      const el=document.getElementById(id);
      if(!el) return null;
      const clone=el.cloneNode(true);
      el.replaceWith(clone);
      return clone;
    }

    const addPrimary=reset('add-primary');
    const addSecondary=reset('add-secondary');
    const addPartner=reset('add-partner');
    const badge=document.getElementById('be-count');
    function updateBadge(){ if(badge) badge.textContent=blocks().length+' blocks'; }

    if(addPrimary) addPrimary.addEventListener('click', function(e){
      e.preventDefault();
      let chosen=pickPrimary();
      if(!chosen){
        const pool=blocks().filter(b=>!isLocked(b));
        if(!pool.length) return;
        pool.sort((a,b)=>area(a)-area(b));
        chosen=pool[0];
      }
      const copy=cloneSanitized(chosen,'Primary');
      insertThirdToLast(copy);
      updateBadge();
    });

    if(addSecondary) addSecondary.addEventListener('click', function(e){
      e.preventDefault();
      let chosen=pickByType('secondary');
      if(!chosen){
        const pool=blocks().filter(b=>!isLocked(b));
        if(!pool.length) return;
        pool.sort((a,b)=>area(a)-area(b));
        chosen=pool[0];
      }
      const copy=cloneSanitized(chosen,'Secondary');
      insertThirdToLast(copy);
      updateBadge();
    });

    if(addPartner) addPartner.addEventListener('click', function(e){
      e.preventDefault();
      const header=pickByType('partner-header');
      const card=pickByType('partner-card');
      if(header) insertThirdToLast(cloneSanitized(header,'Partner header'));
      if(card) insertThirdToLast(cloneSanitized(card,'Partner card'));
      updateBadge();
    });

    updateBadge();
  });
})();
</script>
<script>
(function(){
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once:true });
    else fn();
  }
  function afterLoad(fn){
    if (document.readyState === 'complete') fn();
    else window.addEventListener('load', fn, { once:true });
  }

  function mergePartnerBlocks(){
    const preview = document.getElementById('preview') || document.body;
    const header = preview.querySelector('.be-block[data-type="partner-header"]');
    if (!header) return;
    let card = header.nextElementSibling;
    if (!card || !(card.classList && card.classList.contains('be-block')) || card.dataset.type !== 'partner-card'){
      // try to find the nearest following partner-card
      card = preview.querySelector('.be-block[data-type="partner-card"]');
      if (!card) return;
    }

    // Move ALL children of card into header, preserve order (content first)
    const marker = document.createComment('moved-partner-card-start');
    header.appendChild(marker);
    while (card.firstChild){
      header.appendChild(card.firstChild);
    }
    card.remove();

    // Remove any nested labels/toolbars created inside the moved content (but keep header's own direct ones)
    header.querySelectorAll(':scope .be-label, :scope .be-block-toolbar').forEach(function(el){
      if (el.parentElement !== header){
        el.remove();
      }
    });

    // Zero the gap between header piece and moved card content
    header.style.margin = '0';
    header.style.borderRadius = '22px';
    header.style.overflow = 'hidden'; /* let editor clip inner blue bar correctly */
    const tds = header.querySelectorAll('td');
    tds.forEach(function(td){
      const s = td.getAttribute('style') || '';
      let ns = s.replace(/padding-top\s*:\s*[^;]+;?/gi,'').replace(/padding-bottom\s*:\s*[^;]+;?/gi,'');
      td.setAttribute('style', (ns ? ns + ';' : '') + '');
    });
  }

  // Optional: lightweight de-duper only for partner-header copies
  function installCopyDeduper(){
    const preview = document.getElementById('preview') || document.body;
    preview.addEventListener('click', function(ev){
      const copyBtn = ev.target.closest && ev.target.closest('.be-ico.be-copy');
      if (!copyBtn) return;
      const blk = copyBtn.closest('.be-block');
      if (!blk) return;
      if (blk.dataset.type !== 'partner-header') return; // only dedupe our merged header

      const before = Array.from(preview.querySelectorAll('.be-block[data-type="partner-header"]'));
      setTimeout(function(){
        const after = Array.from(preview.querySelectorAll('.be-block[data-type="partner-header"]'));
        if (after.length <= before.length) return;
        const idx = after.indexOf(blk);
        const tail = after.slice(idx + 1);
        if (tail.length > 1){
          tail.slice(1).forEach(n => n.remove());
        }
      }, 160);
    }, true); // capture but do not stop propagation
  }

  function main(){
    afterLoad(function(){
      mergePartnerBlocks();
      installCopyDeduper();
    });
  }
  main();
})();
</script>
<script>
(function(){
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once:true });
    else fn();
  }
  function afterLoad(fn){
    if (document.readyState === 'complete') fn();
    else window.addEventListener('load', fn, { once:true });
  }

  function text(el){
    return (el?.innerText || '').trim().toLowerCase();
  }

  function findBlockByLabelContains(blocks, needle){
    needle = needle.toLowerCase();
    for (const b of blocks){
      const lab = b.querySelector(':scope > .be-label');
      if (lab && text(lab).includes(needle)) return b;
    }
    return null;
  }

  function mergeIntroGroup(){
    const preview = document.getElementById('preview') || document.body;
    const blocks = Array.from(preview.querySelectorAll('.be-block'));

    const hero   = findBlockByLabelContains(blocks, 'hero banner');
    const date   = findBlockByLabelContains(blocks, 'date bar');
    const author = findBlockByLabelContains(blocks, 'author banner');

    if (!hero || !date || !author) return;

    // Ensure they are in order; if not, sort by document position
    const trio = [hero, date, author].sort((a,b)=> a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1);

    // Move DATE + AUTHOR content *into* HERO (keep hero instrumented)
    for (let i=1;i<trio.length;i++){
      const src = trio[i];
      // Remove nested top-level labels/toolbars from src
      src.querySelectorAll(':scope > .be-label, :scope > .be-block-toolbar').forEach(n => n.remove());
      // Move all children into hero (content only)
      while (src.firstChild){
        hero.appendChild(src.firstChild);
      }
      src.remove();
    }

    // Clean labels/toolbars nested inside hero content (keep only hero's direct label)
    hero.querySelectorAll('.be-label, .be-block-toolbar').forEach(n => {
      if (n.parentElement !== hero) n.remove();
    });

    // Rename the remaining label to "Header section"
    let label = hero.querySelector(':scope > .be-label');
    if (label){
      const span = label.querySelector('span');
      if (span){
        span.innerHTML = '<span class="dot"></span> Header section';
      } else {
        label.innerHTML = '<span><span class="dot"></span> Header section</span>';
      }
    } else {
      // If no label, create one
      label = document.createElement('div');
      label.className = 'be-label';
      label.innerHTML = '<span><span class="dot"></span> Header section</span>';
      hero.insertBefore(label, hero.firstChild);
    }

    // Mark as intro-locked for styling/observation
    hero.dataset.type = 'intro-locked';
    hero.dataset.label = 'Header section';

    // Remove the top toolbar entirely for this block
    hero.querySelectorAll(':scope > .be-block-toolbar').forEach(n => n.remove());

    // Tighten internal spacing a bit
    hero.style.margin = '0';
    // Rounded wrapper: we won't force overflow hidden to avoid clipping any editor controls
    hero.style.borderRadius = '22px';

    // Also remove any toolbar/labels that appear later (editor mutations)
    const mo = new MutationObserver(function(muts){
      muts.forEach(m => {
        (m.addedNodes || []).forEach(node => {
          if (!(node instanceof HTMLElement)) return;
          const host = node.closest && node.closest('.be-block');
          if (host === hero){
            // strip any toolbars/labels added within the hero
            hero.querySelectorAll(':scope > .be-block-toolbar').forEach(n => n.remove());
            hero.querySelectorAll('.be-label, .be-block-toolbar').forEach(n => {
              if (n.parentElement !== hero) n.remove();
            });
          }
        });
      });
    });
    mo.observe(hero, { childList:true, subtree:true });
  }

  function installGlobalCSS(){
    const css = document.createElement('style');
    css.textContent = `
      .be-block[data-type="intro-locked"] > .be-block-toolbar{ display:none !important; }
      .be-block[data-type="intro-locked"] .be-block .be-block-toolbar{ display:none !important; }
      .be-block[data-type="intro-locked"] .be-block .be-label{ display:none !important; }
      /* keep the block editable – we're not disabling content editing, only the move/copy/delete UI */
    `;
    document.head.appendChild(css);
  }

  function main(){
    onReady(installGlobalCSS);
    afterLoad(mergeIntroGroup);
  }
  main();
})();
</script>
<style>
/* --- Global toolbar positioning + hover/active visibility --- */
.be-block{ position: relative; }
.be-block > .be-block-toolbar{
  position: absolute !important;
  top: 0 !important;
  right: 0 !important;
  z-index: 9999 !important;
  display: inline-flex;
  gap: 6px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 120ms ease-in-out;
}
/* Show toolbar when hovering the block, or when it's the active/editing block */
.be-block:hover > .be-block-toolbar,
.be-block.is-active > .be-block-toolbar{
  opacity: 1;
  pointer-events: auto;
}

/* Keep toolbars hidden for locked intro section */
.be-block[data-type="intro-locked"] > .be-block-toolbar{ display:none !important; }

/* Partner/others: ensure no clipping of the toolbar */
.be-block{ overflow: visible; }
</style><script>
(function(){
  var root = document.getElementById('preview') || document.body;

  function findBlock(el){
    return el && el.closest ? el.closest('.be-block') : null;
  }
  function clearActive(except){
    root.querySelectorAll('.be-block.is-active').forEach(function(n){
      if (n !== except) n.classList.remove('is-active');
    });
  }

  // Mark block active on focus/click inside
  root.addEventListener('focusin', function(e){
    var blk = findBlock(e.target);
    if (!blk) return;
    blk.classList.add('is-active');
    clearActive(blk);
  });
  root.addEventListener('mousedown', function(e){
    var blk = findBlock(e.target);
    if (!blk) return;
    blk.classList.add('is-active');
    clearActive(blk);
  });

  // Remove active when focus leaves the block (with a small delay to allow focus to move within)
  root.addEventListener('focusout', function(e){
    var blk = findBlock(e.target);
    if (!blk) return;
    setTimeout(function(){
      if (!blk.contains(document.activeElement)){
        blk.classList.remove('is-active');
      }
    }, 50);
  });

  // If user clicks outside any block, clear active
  document.addEventListener('click', function(e){
    if (!findBlock(e.target)){
      clearActive(null);
    }
  });
})();
</script><style>
/* Floating formatting toolbar that follows the active block */
#be-toolbar {
  position: fixed;
  left: 0;
  top: 0;
  transform: translate(-50%, -100%);
  z-index: 10050;
  opacity: 0;
  pointer-events: auto;
  transition: opacity 120ms ease;
}
#be-toolbar.is-visible { opacity: 1; }

/* Ensure per-block toolbars stay at top-right of their block */
.be-block { position: relative; overflow: visible; }
.be-block > .be-block-toolbar{
  position: absolute !important;
  top: 0 !important;
  right: 0 !important;
  z-index: 9990;
  display: inline-flex;
  gap: 6px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 120ms ease-in-out;
}
.be-block:hover > .be-block-toolbar,
.be-block.is-active > .be-block-toolbar{
  opacity: 1;
  pointer-events: auto;
}
</style><script>
(function(){
  const toolbar = document.getElementById('be-toolbar');
  if (!toolbar) return;

  const root = document.getElementById('preview') || document.body;
  let activeBlock = null, rafId = 0;
  const MARGIN = 8;

  function setVisible(v){ toolbar.classList.toggle('is-visible', v); }
  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  function updatePos(){
    rafId = 0;
    if (!activeBlock){
      setVisible(false);
      return;
    }
    const rect = activeBlock.getBoundingClientRect();
    if (!rect || rect.width === 0 || rect.height === 0){
      setVisible(false);
      return;
    }
    const vw = Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

    let x = rect.left + rect.width / 2;
    x = clamp(x, MARGIN, vw - MARGIN);

    let top = rect.top - MARGIN;
    if (top < MARGIN){
      top = rect.bottom + MARGIN;
      toolbar.style.transform = 'translate(-50%, 0)';
    } else {
      toolbar.style.transform = 'translate(-50%, -100%)';
    }

    toolbar.style.left = x + 'px';
    toolbar.style.top  = top + 'px';
    setVisible(true);
  }
  function reqUpdate(){ if (!rafId) rafId = requestAnimationFrame(updatePos); }

  function findBlock(el){ return el && el.closest ? el.closest('.be-block') : null; }
  function clearActive(except){
    root.querySelectorAll('.be-block.is-active').forEach(n => { if (n !== except) n.classList.remove('is-active'); });
  }

  // Keep track of the active block
  root.addEventListener('focusin', (e) => { const b = findBlock(e.target); if (b){ activeBlock = b; b.classList.add('is-active'); clearActive(b); reqUpdate(); }});
  root.addEventListener('click',   (e) => { const b = findBlock(e.target); if (b){ activeBlock = b; b.classList.add('is-active'); clearActive(b); reqUpdate(); } else { activeBlock = null; clearActive(null); setVisible(false); }});

  document.addEventListener('selectionchange', reqUpdate);
  window.addEventListener('scroll',  reqUpdate, true);
  window.addEventListener('resize',  reqUpdate);

  // Expose for programmatic repositioning
  window.repositionBeToolbar = reqUpdate;
})();
</script><style>
/* Ensure the style editor toolbar exists and is always visible */
#be-toolbar{
  position: fixed !important;
  z-index: 10050 !important;
  opacity: 1 !important;
  pointer-events: auto !important;
}
</style><script>
(function(){
  // Ensure toolbar exists with default content if editor didn't inject it
  var tb = document.getElementById('be-toolbar');
  if (!tb){
    tb = document.createElement('div');
    tb.id = 'be-toolbar';
    tb.className = 'be-toolbar';
    tb.setAttribute('role', 'toolbar');
    tb.setAttribute('aria-label', 'Formatting');
    tb.innerHTML = ''
      + '<button data-cmd="bold"><strong>B</strong></button>'
      + '<button data-cmd="italic"><em>I</em></button>'
      + '<button data-cmd="underline"><u>U</u></button>'
      + '<span class="be-sep"></span>'
      + '<button data-cmd="insertUnorderedList">• List</button>'
      + '<button data-cmd="insertOrderedList">1. List</button>'
      + '<span class="be-sep"></span>'
      + '<button data-cmd="formatBlock" data-value="H2">H2</button>'
      + '<button data-cmd="formatBlock" data-value="H3">H3</button>'
      + '<span class="be-sep"></span>'
      + '<button id="be-link">Link</button>'
      + '<button id="be-clear">Clear</button>';
    (document.body || document.documentElement).appendChild(tb);
  }

  // Make it float over current .be-block (above by default, below if near viewport top)
  var root = document.getElementById('preview') || document.body;
  var activeBlock = null, raf = 0, MARGIN = 8;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function findBlock(el){ return el && el.closest ? el.closest('.be-block') : null; }

  function positionToolbar(){
    raf = 0;
    var rect = activeBlock && activeBlock.getBoundingClientRect();
    if (!rect || !rect.width || !rect.height) return;
    var vw = Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
    var vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

    var x = clamp(rect.left + rect.width/2, MARGIN, vw - MARGIN);
    var aboveTop = rect.top - MARGIN;
    var belowTop = rect.bottom + MARGIN;

    if (aboveTop < MARGIN){
      tb.style.transform = 'translate(-50%, 0)';
      tb.style.top = belowTop + 'px';
    } else {
      tb.style.transform = 'translate(-50%, -100%)';
      tb.style.top = aboveTop + 'px';
    }
    tb.style.left = x + 'px';
  }
  function req(){ if (!raf) raf = requestAnimationFrame(positionToolbar); }

  function activate(b){
    if (!b) return;
    if (activeBlock === b) { req(); return; }
    activeBlock = b;
    // highlight active for per-block toolbar CSS if present
    try {
      root.querySelectorAll('.be-block.is-active').forEach(function(n){ if(n!==b) n.classList.remove('is-active'); });
      b.classList.add('is-active');
    } catch(e){}
    req();
  }

  root.addEventListener('focusin', function(e){ var b=findBlock(e.target); if (b) activate(b); });
  root.addEventListener('click',   function(e){ var b=findBlock(e.target); if (b) activate(b); });

  document.addEventListener('selectionchange', req);
  window.addEventListener('scroll', req, true);
  window.addEventListener('resize', req);

  // If nothing is active on load, use the first editable block
  window.addEventListener('load', function(){
    var first = root.querySelector('.be-block:not([data-type="intro-locked"])');
    if (first) activate(first);
  });
})();
</script><style>
/* High-contrast styling for the floating formatting toolbar buttons */
#be-toolbar {
  background: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.12);
  padding: 6px 8px;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
#be-toolbar button {
  font: 500 13px/1 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  border: 1px solid #d1d5db;
  background: #fff;
  border-radius: 8px;
  min-width: 28px;
  height: 28px;
  padding: 0 10px;
  cursor: pointer;
  transition: border-color 120ms ease, background 120ms ease, transform 80ms ease;
}
#be-toolbar button strong,
#be-toolbar button em,
#be-toolbar button u { font-weight: 700; font-style: normal; text-decoration: none; }
#be-toolbar button:hover { border-color: #9ca3af; background: #f9fafb; }
#be-toolbar button:active { transform: translateY(1px); }
#be-toolbar .be-sep { width: 1px; height: 20px; background: #e5e7eb; margin: 0 6px; }

/* Per-block toolbars pinned to top-right; show on hover/active */
.be-block { position: relative; overflow: visible; }
.be-block > .be-block-toolbar {
  position: absolute !important;
  top: 0 !important;
  right: 0 !important;
  z-index: 10000;
  display: inline-flex;
  gap: 6px;
  opacity: 0;
  pointer-events: none;
  padding: 2px;
  background: rgba(255,255,255,0.9);
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.06);
  transition: opacity 120ms ease-in-out;
}
.be-block:hover > .be-block-toolbar,
.be-block.is-active > .be-block-toolbar {
  opacity: 1;
  pointer-events: auto;
}

/* Keep intro section locked (no move/copy/delete) */
.be-block[data-type="intro-locked"] > .be-block-toolbar { display: none !important; }
</style><style>
/* Hide any duplicate toolbars beyond the first within a block */
.be-block > .be-block-toolbar ~ .be-block-toolbar { display: none !important; }
/* Within the toolbar, hide duplicate buttons beyond the first occurrence */
.be-block > .be-block-toolbar .be-ico.be-copy ~ .be-ico.be-copy { display: none !important; }
.be-block > .be-block-toolbar .be-ico.be-delete ~ .be-ico.be-delete { display: none !important; }
.be-block > .be-block-toolbar .be-ico.be-handle ~ .be-ico.be-handle { display: none !important; }

/* Keep per-block toolbar at top-right and styled */
.be-block { position: relative; overflow: visible; }
.be-block > .be-block-toolbar {
  position: absolute !important;
  top: 0 !important;
  right: 0 !important;
  z-index: 10000;
  display: inline-flex;
  gap: 6px;
  padding: 2px;
  background: rgba(255,255,255,0.9);
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.06);
}

</style><script>
(function(){
  function addMissingToolbars(){
    var root = document.getElementById('preview') || document.body;
    var blocks = root.querySelectorAll('.be-block');
    for (var i=0; i<blocks.length; i++){
      var b = blocks[i];
      if (b.dataset && b.dataset.type === 'intro-locked') continue;
      // check for a direct child toolbar
      var hasBar = false;
      for (var c = b.firstElementChild; c; c = c.nextElementSibling){
        if (c.classList && c.classList.contains('be-block-toolbar')){ hasBar = true; break; }
      }
      if (!hasBar){
        var bar = document.createElement('div');
        bar.className = 'be-block-toolbar';
        // create standard buttons
        var h = document.createElement('button'); h.className='be-ico be-handle'; h.textContent='⋮⋮';
        var cp= document.createElement('button'); cp.className='be-ico be-copy';   cp.textContent='Copy';
        var dl= document.createElement('button'); dl.className='be-ico be-delete'; dl.textContent='Delete';
        bar.appendChild(h); bar.appendChild(cp); bar.appendChild(dl);
        b.insertBefore(bar, b.firstElementChild);
      }
    }
    if (window.repositionBeToolbar) window.repositionBeToolbar();
  }
  if (document.readyState === 'complete') addMissingToolbars();
  else window.addEventListener('load', addMissingToolbars, { once:true });
})();
</script><script>
(function(){
  function ensureDisclaimerStructure(){
    try{
      var blocks = document.querySelectorAll('.be-block[data-type="disclaimer"]');
      for (var i=0;i<blocks.length;i++){
        var block = blocks[i];
        // Ensure label exists
        var hasLabel = false;
        for (var c = block.firstElementChild; c; c = c.nextElementSibling){
          if (c.classList && c.classList.contains('be-label')){ hasLabel = true; break; }
        }
        if (!hasLabel){
          var label = document.createElement('div');
          label.className = 'be-label';
          label.innerHTML = '<span><span class="dot"></span> Disclaimer</span>';
          block.insertBefore(label, block.firstElementChild);
        }
        // Ensure a single direct toolbar right after label
        var labelNode = block.querySelector(':scope > .be-label');
        var directBars = block.querySelectorAll(':scope > .be-block-toolbar');
        var bar = directBars[0];
        for (var j=1;j<directBars.length;j++){ directBars[j].remove(); }
        if (!bar){
          // promote nested if any
          var nested = block.querySelector('.be-block-toolbar');
          if (nested){ bar = nested; } else { bar = document.createElement('div'); bar.className = 'be-block-toolbar'; }
          if (labelNode && labelNode.nextSibling){
            block.insertBefore(bar, labelNode.nextSibling);
          } else {
            block.insertBefore(bar, block.firstElementChild);
          }
        }else{
          if (labelNode && bar.previousElementSibling !== labelNode){
            block.insertBefore(bar, labelNode.nextSibling);
          }
        }
        // Ensure one of each button
        function need(sel, mk){
          var btn = bar.querySelector(sel);
          if (!btn){ btn = mk(); bar.appendChild(btn); }
          return btn;
        }
        var handle = need('.be-ico.be-handle', function(){ var b=document.createElement('button'); b.className='be-ico be-handle'; b.textContent='⋮⋮'; return b; });
        var copy   = need('.be-ico.be-copy',   function(){ var b=document.createElement('button'); b.className='be-ico be-copy';   b.textContent='Copy'; return b; });
        var del    = need('.be-ico.be-delete', function(){ var b=document.createElement('button'); b.className='be-ico be-delete'; b.textContent='Delete'; return b; });
        // Order by moving nodes
        bar.appendChild(handle); bar.appendChild(copy); bar.appendChild(del);
      }
    }catch(e){ try{ console.warn('ensureDisclaimerStructure error', e); }catch(_){ } }
  }

  // Delegated click handler so it works for future clones too
  function onClick(e){
    var copyBtn = e.target.closest && e.target.closest('.be-block[data-type="disclaimer"] .be-block-toolbar .be-copy');
    var delBtn  = e.target.closest && e.target.closest('.be-block[data-type="disclaimer"] .be-block-toolbar .be-delete');
    if (!copyBtn && !delBtn) return;

    e.preventDefault();
    e.stopPropagation();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();

    var block = (copyBtn || delBtn).closest('.be-block[data-type="disclaimer"]');
    if (!block) return;

    if (delBtn){
      // Remove the entire block
      if (block.parentNode) block.parentNode.removeChild(block);
      return;
    }

    if (copyBtn){
      // Clone the block and clean IDs
      var clone = block.cloneNode(true);
      var withId = clone.querySelectorAll('[id]');
      for (var i=0;i<withId.length;i++){ withId[i].removeAttribute('id'); }
      // Insert after and ensure its structure (toolbar/label placement)
      block.parentNode.insertBefore(clone, block.nextSibling);
      // No need to wire events—delegation handles future clicks
      // Ensure toolbar/label positioning on the clone
      requestAnimationFrame(ensureDisclaimerStructure);
    }
  }

  // Run once on load to ensure structure, then install delegated handler
  if (document.readyState === 'complete'){ ensureDisclaimerStructure(); }
  else window.addEventListener('load', ensureDisclaimerStructure, { once:true });

  document.addEventListener('click', onClick, true); // capture to beat editor handlers
})();
</script><script>(function(){
  // Run after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupFix, { once: true });
  } else {
    setupFix();
  }

  function setupFix(){
    const preview = document.getElementById('preview');
    if (!preview) return;

    // Replace buttons with clean clones to drop any older listeners
    function resetButton(id){
      const btn = document.getElementById(id);
      if (!btn) return null;
      const clone = btn.cloneNode(true);
      btn.replaceWith(clone);
      return clone;
    }

    const addPrimary   = resetButton('add-primary');
    const addSecondary = resetButton('add-secondary');
    const addPartner   = resetButton('add-partner');

    const badge = document.getElementById('be-count');
    function updateBadge(){
      if (badge) badge.textContent = (preview.querySelectorAll('.be-block').length) + ' blocks';
    }
    updateBadge();

    const isLocked = b => (b?.dataset?.type === 'locked');

    function area(el){
      const r = el.getBoundingClientRect();
      return (r.width || 1) * (r.height || 1);
    }

    function tableCount(el){
      // prefer a direct table (common for unit blocks)
      const direct = el.querySelectorAll(':scope > table').length;
      return direct || el.querySelectorAll('table').length;
    }

    function pickTemplate(type){
      const all = Array.from(preview.querySelectorAll('.be-block')).filter(Boolean);
      const candidates = all.filter(b => b.dataset && b.dataset.type === type && !isLocked(b));
      if (!candidates.length) return null;

      const scored = candidates.map(el => ({
        el, tables: tableCount(el), area: area(el)
      }));

      const singles = scored.filter(s => s.tables === 1);
      const pool = singles.length ? singles : scored;
      const chosen = pool.sort((a,b) => a.area - b.area)[0].el;

      // Deep clone + sanitize duplicate IDs
      const clone = chosen.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));

      // Optional: relabel copy for clarity
      const labelSpan = clone.querySelector('.be-label span');
      const nice = (chosen.dataset && chosen.dataset.label) ? chosen.dataset.label
                 : (type.charAt(0).toUpperCase() + type.slice(1));
      if (labelSpan) labelSpan.textContent = nice + ' (copy)';

      return clone;
    }

    function appendClone(type){
      const node = pickTemplate(type);
      if (!node) {
        // Fallback: take the smallest non-locked block if type not found
        const pool = Array.from(preview.querySelectorAll('.be-block')).filter(b => !isLocked(b));
        if (!pool.length) return;
        const chosen = pool.sort((a,b) => area(a) - area(b))[0];
        const fallback = chosen.cloneNode(true);
        fallback.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
        preview.appendChild(fallback);
      } else {
        preview.appendChild(node);
      }
      updateBadge();
    }

    if (addPrimary)   addPrimary.addEventListener('click', function(e){ e.preventDefault(); appendClone('primary'); }, { passive:false });
    if (addSecondary) addSecondary.addEventListener('click', function(e){ e.preventDefault(); appendClone('secondary'); }, { passive:false });
    if (addPartner)   addPartner.addEventListener('click', function(e){
      e.preventDefault();
      const header = pickTemplate('partner-header');
      const card   = pickTemplate('partner-card');
      if (header) preview.appendChild(header);
      if (card)   preview.appendChild(card);
      updateBadge();
    }, { passive:false });
  }
})();
</script>
<script>
(function(){
  // Enhance the safe-clone behavior: Primary must insert a white card like "Story 1 card"
  function ready(fn){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true }); else fn(); }
  ready(function(){
    const preview = document.getElementById('preview');
    const addPrimary = document.getElementById('add-primary');
    if (!preview || !addPrimary) return;

    // Overwrite any existing listener by replacing the node
    const btn = addPrimary.cloneNode(true);
    addPrimary.replaceWith(btn);

    function isLocked(b){ return b?.dataset?.type === 'locked'; }

    function area(el){
      const r = el.getBoundingClientRect();
      return (r.width || 1) * (r.height || 1);
    }

    function tableCount(el){
      const direct = el.querySelectorAll(':scope > table').length;
      return direct || el.querySelectorAll('table').length;
    }

    function hasWhiteBg(el){
      // Look for inline styles or attributes indicating white background
      const w = /(#fff(fff)?\\b|\\bwhite\\b)/i;
      if (el.getAttribute('bgcolor') && w.test(el.getAttribute('bgcolor'))) return true;
      if (el.hasAttribute('style') && w.test(el.getAttribute('style'))) return true;
      // Check tables within
      const t = el.querySelector('table');
      if (t){
        if (t.getAttribute('bgcolor') && w.test(t.getAttribute('bgcolor'))) return true;
        if (t.hasAttribute('style') && w.test(t.getAttribute('style'))) return true;
      }
      return false;
    }

    function textIncludes(el, s){
      return (el.textContent || '').toLowerCase().includes(s.toLowerCase());
    }

    function findStory1Primary(){
      const primaries = Array.from(preview.querySelectorAll('.be-block')).filter(b => b.dataset?.type === 'primary' && !isLocked(b));
      if (!primaries.length) return null;

      // 1) Exact label match in data-label or visible label
      let exact = primaries.find(b => /story\\s*1/i.test(b.dataset?.label || ''));
      if (!exact){
        exact = primaries.find(b => /story\\s*1/i.test((b.querySelector('.be-label')?.textContent)||''));
      }
      if (exact) return exact;

      // 2) Prefer white background + single table
      const scored = primaries.map(el => ({
        el,
        white: hasWhiteBg(el) ? 1 : 0,
        tables: tableCount(el),
        area: area(el),
        storyHint: (/(story|card)/i.test(el.dataset?.label || '') || /(story|card)/i.test((el.querySelector('.be-label')?.textContent)||'')) ? 1 : 0,
      }));

      scored.sort((a,b)=>{
        // Prefer white, then story hint, then single-table, then smallest area
        return (b.white - a.white) || (b.storyHint - a.storyHint) || ((a.tables===1)-(b.tables===1)) || (a.area - b.area);
      });

      return scored[0]?.el || null;
    }

    function cloneSanitized(node){
      const clone = node.cloneNode(true);
      clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
      const labelSpan = clone.querySelector('.be-label span');
      const nice = (node.dataset && node.dataset.label) ? node.dataset.label : 'Primary';
      if (labelSpan) labelSpan.textContent = nice + ' (copy)';
      return clone;
    }

    btn.addEventListener('click', function(e){
      e.preventDefault();
      let chosen = findStory1Primary();
      if (!chosen){
        // Fallback: smallest non-locked primary; then any smallest non-locked block
        const primaries = Array.from(preview.querySelectorAll('.be-block')).filter(b => b.dataset?.type === 'primary' && !isLocked(b));
        if (primaries.length){
          primaries.sort((a,b)=> area(a) - area(b));
          chosen = primaries[0];
        } else {
          const pool = Array.from(preview.querySelectorAll('.be-block')).filter(b => !isLocked(b));
          if (!pool.length) return;
          pool.sort((a,b)=> area(a) - area(b));
          chosen = pool[0];
        }
      }
      const copy = cloneSanitized(chosen);
      preview.appendChild(copy);
      const badge = document.getElementById('be-count');
      if (badge) badge.textContent = (preview.querySelectorAll('.be-block').length) + ' blocks';
    }, { passive:false });
  });
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once:true }); else fn(); }
  ready(function(){
    const preview = document.getElementById('preview');
    const addPrimary = document.getElementById('add-primary');
    if (!preview || !addPrimary) return;
    const btn = addPrimary.cloneNode(true);
    addPrimary.replaceWith(btn);

    function isLocked(b){ return b?.dataset?.type === 'locked'; }
    function area(el){ const r=el.getBoundingClientRect(); return (r.width||1)*(r.height||1); }
    function tableCount(el){ const direct = el.querySelectorAll(':scope > table').length; return direct || el.querySelectorAll('table').length; }
    function hasWhiteBg(el){ const w=/(#fff(fff)?\\b|\\bwhite\\b)/i;
      if (el.getAttribute('bgcolor') && w.test(el.getAttribute('bgcolor'))) return true;
      if (el.hasAttribute('style') && w.test(el.getAttribute('style'))) return true;
      const t=el.querySelector('table'); if(t){ if(t.getAttribute('bgcolor') && w.test(t.getAttribute('bgcolor'))) return true;
        if(t.hasAttribute('style') && w.test(t.getAttribute('style'))) return true; }
      return false; }
    function findStory1Primary(){
      const primaries=[...preview.querySelectorAll('.be-block')].filter(b=>b.dataset?.type==='primary' && !isLocked(b));
      if(!primaries.length) return null;
      let exact=primaries.find(b=>/story\\s*1/i.test(b.dataset?.label||'')); if(!exact){ exact=primaries.find(b=>/story\\s*1/i.test((b.querySelector('.be-label')?.textContent)||'')); }
      if(exact) return exact;
      const scored=primaries.map(el=>({el,white:hasWhiteBg(el)?1:0,tables:tableCount(el),area:area(el),
        storyHint:(/(story|card)/i.test(el.dataset?.label||'')||/(story|card)/i.test((el.querySelector('.be-label')?.textContent)||''))?1:0 }));
      scored.sort((a,b)=>(b.white-a.white)||(b.storyHint-a.storyHint)||((a.tables===1)-(b.tables===1))||(a.area-b.area));
      return scored[0]?.el||null;
    }
    function cloneSanitized(node){ const clone=node.cloneNode(true); clone.querySelectorAll('[id]').forEach(n=>n.removeAttribute('id'));
      const labelSpan=clone.querySelector('.be-label span'); const nice=(node.dataset&&node.dataset.label)?node.dataset.label:'Primary';
      if(labelSpan) labelSpan.textContent=nice+' (copy)'; return clone; }

    btn.addEventListener('click', function(e){
      e.preventDefault();
      let chosen=findStory1Primary(); if(!chosen){ const primaries=[...preview.querySelectorAll('.be-block')].filter(b=>b.dataset?.type==='primary'&&!isLocked(b));
        if(primaries.length){ primaries.sort((a,b)=>area(a)-area(b)); chosen=primaries[0]; }
        else { const pool=[...preview.querySelectorAll('.be-block')].filter(b=>!isLocked(b)); if(!pool.length) return; pool.sort((a,b)=>area(a)-area(b)); chosen=pool[0]; } }
      const copy=cloneSanitized(chosen);

      // Insert before the Subscribe CTA line
      let target=[...preview.querySelectorAll('.be-block')].find(b=>/subscribe cta/i.test(b.dataset?.label||'')||/subscribe cta/i.test((b.textContent||'')));
      if(target) target.before(copy); else preview.appendChild(copy);

      const badge=document.getElementById('be-count');
      if(badge) badge.textContent=preview.querySelectorAll('.be-block').length+' blocks';
    }, {passive:false});
  });
})();</script><script>
// --- Hard lock placement for Primary, Secondary & Partner by intercepting preview.appendChild ---
(function(){
  var preview = document.getElementById('preview') || document.body;
  if (!preview) return;

  var origAppend = preview.appendChild.bind(preview);

  
  function findClosestBlockByText(regex){
    var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null);
    var matches = [];
    while (walker.nextNode()){
      var el = walker.currentNode;
      if (!el) continue;
      var txt = (el.textContent || '').trim();
      if (!txt) continue;
      if (regex.test(txt)){
        var block = el.closest && el.closest('.be-block');
        if (block) matches.push(block);
      }
    }
    return matches.length ? matches[matches.length-1] : null;
  }

  
  function findClosestBlockByText(regex){
    try{
      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null);
      var matches = [];
      while (walker.nextNode()){
        var el = walker.currentNode;
        if (!el) continue;
        var txt = (el.textContent || '').trim();
        if (!txt) continue;
        if (regex.test(txt)){
          var block = el.closest && el.closest('.be-block');
          if (block) matches.push(block);
        }
      }
      return matches.length ? matches[matches.length-1] : null;
    }catch(_){ return null; }
  }

  function anchor(){
    var preview = document.getElementById('preview') || document.body;
    var a = document.querySelector('.be-block[data-type="primary"][data-label="Row 23: Subscribe CTA line"]');
    if (a) return a;
    a = document.querySelector('.be-block[data-type="disclaimer"]');
    if (!a){ a = findClosestBlockByText(/(SoFi Disclaimers|Disclaimer: Finder|INVESTMENTS ARE NOT FDIC INSURED)/i); }
    if (a) return a;
    a = Array.from(preview.querySelectorAll('.be-block')).find(function(b){
      var lbl = (b.dataset && b.dataset.label) ? b.dataset.label : '';
      return /dynamic content block/i.test(lbl) || /row\s*26:\s*dynamic/i.test(lbl);
    });
    if (!a){ a = findClosestBlockByText(/Dynamic content block/i); }
    if (a) return a;
    return null;
  }

  preview.appendChild = function(node){
    try{
      if (node && node.nodeType === 1 && node.classList && node.classList.contains('be-block')){
        var t = (node.dataset && node.dataset.type) || '';
        if (t === 'primary' || t === 'secondary' || t === 'partner-header' || t === 'partner-card'){
          var a = anchor();
          if (a && a.parentNode){
            var p = a.parentNode;
            if (node.parentNode !== p) p.appendChild(node);
            p.insertBefore(node, a); // <— force BEFORE Row 23
            return node;
          }
        }
      }
    }catch(_){}
    return origAppend(node); // default for everything else (including Primary)
  };
})();
</script><script>
// Final override: intercept ONLY when parent is inside #preview (avoids fragment/build-phase issues)
(function(){
  var preview = document.getElementById('preview') || document.body;

  function findClosestBlockByText(regex){
    try{
      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null);
      var matches = [];
      while (walker.nextNode()){
        var el = walker.currentNode;
        if (!el) continue;
        var txt = (el.textContent || '').trim();
        if (!txt) continue;
        if (regex.test(txt)){
          var block = el.closest && el.closest('.be-block');
          if (block) matches.push(block);
        }
      }
      return matches.length ? matches[matches.length-1] : null;
    }catch(_){ return null; }
  }

  function anchor(){
    var a = document.querySelector('.be-block[data-type="primary"][data-label="Row 23: Subscribe CTA line"]');
    if (a) return a;

    a = document.querySelector('.be-block[data-type="disclaimer"]');
    if (!a){
      a = findClosestBlockByText(/(SoFi Disclaimers|Disclaimer: Finder|INVESTMENTS ARE NOT FDIC INSURED)/i);
    }
    if (a) return a;

    a = Array.from(preview.querySelectorAll('.be-block')).find(function(b){
      var lbl = (b.dataset && b.dataset.label) ? b.dataset.label : '';
      return /dynamic content block/i.test(lbl) || /row\s*26:\s*dynamic/i.test(lbl);
    });
    if (!a){
      a = findClosestBlockByText(/Dynamic content block/i);
    }
    if (a) return a;

    return null; // no anchors -> append to bottom
  }

  var prevAppend = Element.prototype.appendChild;
  Element.prototype.appendChild = function(node){
    var parent = this;
    var inPreview = false;
    try { inPreview = preview && preview.contains && preview.contains(parent); } catch(_) {}

    // Only take over for real .be-blocks appended into the live preview tree
    if (inPreview && node && node.nodeType === 1 && node.classList && node.classList.contains('be-block')){
      var t = (node.dataset && node.dataset.type) || '';
      if (t === 'primary' || t === 'secondary' || t === 'partner-header' || t === 'partner-card'){
        var a = anchor();
        if (a && a.parentNode){
          var p = a.parentNode;
          // ensure node is under the same parent once
          if (node.parentNode !== p) prevAppend.call(p, node);
          if (node !== a) p.insertBefore(node, a);
          return node;
        }
        // no anchor -> let it append at bottom naturally
        return prevAppend.call(parent, node);
      }
    }
    return prevAppend.call(parent, node);
  };
})();</script><script>
// Partner Add Guardian: only overrides when header/card is missing; otherwise lets native handler run.
(function(){
  var root = document.getElementById('preview') || document.body;
  var btn = document.getElementById('add-partner');
  if (!root || !btn) return;

  function exists(sel){ return !!root.querySelector(sel); }
  function build(id){
    var tpl = document.getElementById(id);
    return (tpl && tpl.content && tpl.content.firstElementChild) ? tpl.content.firstElementChild.cloneNode(true) : null;
  }

  btn.addEventListener('click', function(ev){
    var needHeader = !exists('.be-block[data-type="partner-header"]');
    var needCard   = !exists('.be-block[data-type="partner-card"]');
    if (needHeader || needCard){
      // Stop native listener (which appears to no-op after deleting the default card)
      ev.preventDefault();
      ev.stopImmediatePropagation();
      ev.stopPropagation();

      // Synthesize only the missing pieces
      if (needHeader){
        var h = build('tpl-partner-header');
        if (h) root.appendChild(h);
      }
      if (needCard){
        var c = build('tpl-partner-card');
        if (c) root.appendChild(c);
      }
      return false;
    }
    // Otherwise, do nothing here and allow native handler to proceed normally
  }, true); // capture phase
})();
</script><script>
/* Override Partner Add: always inserts fresh Partner header + card (works even after deletes) */
(function(){
  var preview = document.getElementById('preview') || document.body;
  var btn = document.getElementById('add-partner');
  if (!preview || !btn) return;

  // Ensure templates exist (idempotent)
  function ensureTemplate(id, html){
    if (!document.getElementById(id)){
      var t = document.createElement('template');
      t.id = id;
      t.innerHTML = html.trim();
      document.body.appendChild(t);
    }
  }

  ensureTemplate('tpl-partner-header', '\
    <div class="be-block" data-type="partner-header" data-label="Partner header">\
      <div class="be-label"><i class="dot"></i><span>Partner header</span></div>\
      <div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>\
      <table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>\
        <table class="container" role="presentation" width="685"><tbody><tr><td>\
          <h3 class="font-sans">Partner</h3>\
        </td></tr></tbody></table>\
      </td></tr></tbody></table>\
    </div>\
  ');

  ensureTemplate('tpl-partner-card', '\
    <div class="be-block" data-type="partner-card" data-label="Partner card">\
      <div class="be-label"><i class="dot"></i><span>Partner card</span></div>\
      <div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>\
      <table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>\
        <table class="container bg-white" role="presentation" width="685"><tbody><tr><td class="px-25">\
          <p class="font-sans">Partner content…</p>\
        </td></tr></tbody></table>\
      </td></tr></tbody></table>\
    </div>\
  ');

  function fromTemplate(id){
    var t = document.getElementById(id);
    return (t && t.content && t.content.firstElementChild) ? t.content.firstElementChild.cloneNode(true) : null;
  }
  function cloneExisting(sel){
    var n = preview.querySelector(sel);
    return n ? n.cloneNode(true) : null;
  }
  function minimal(type, label, inner){
    var wrap = document.createElement('div');
    wrap.innerHTML = (
      '<div class="be-block" data-type="'+type+'" data-label="'+label+'">'+
        '<div class="be-label"><i class="dot"></i><span>'+label+'</span></div>'+
        '<div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>'+
        inner+
      '</div>'
    );
    return wrap.firstElementChild;
  }
  function buildHeader(){
    return fromTemplate('tpl-partner-header')
        || cloneExisting('.be-block[data-type="partner-header"]')
        || minimal('partner-header','Partner header',
           '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>'+
           '<table class="container" role="presentation" width="685"><tbody><tr><td><h3 class="font-sans">Partner</h3></td></tr></tbody></table>'+
           '</td></tr></tbody></table>');
  }
  function buildCard(){
    return fromTemplate('tpl-partner-card')
        || cloneExisting('.be-block[data-type="partner-card"]')
        || minimal('partner-card','Partner card',
           '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>'+
           '<table class="container bg-white" role="presentation" width="685"><tbody><tr><td class="px-25">'+
           '<p class="font-sans">Partner content…</p></td></tr></tbody></table>'+
           '</td></tr></tbody></table>');
  }

  // Replace the Partner button node to drop ALL existing listeners, then attach our own
  var freshBtn = btn.cloneNode(true);
  btn.parentNode.replaceChild(freshBtn, btn);

  freshBtn.addEventListener('click', function(e){
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    var header = buildHeader();
    var card   = buildCard();
    if (header) preview.appendChild(header);
    if (card)   preview.appendChild(card);

    try { if (typeof updateBadge === 'function') updateBadge(); } catch(_){}
  }, false);
})();
</script><script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script><script>
/* Global spacer helper (idempotent) */
window.addSpacersToContent = window.addSpacersToContent || function(html){
  try{
    var doc = document.implementation.createHTMLDocument('spacers');
    var c = doc.createElement('div'); c.innerHTML = html;
    var blockSelectors = ['p','ul','ol','h1','h2','h3','h4','h5','h6','table','blockquote','pre','img','figure'];
    blockSelectors.forEach(function(tag){
      Array.prototype.slice.call(c.querySelectorAll(tag)).forEach(function(el){
        // skip empty paragraphs
        if (tag==='p' && !el.textContent.trim() && !el.querySelector('img,table,ul,ol')) return;
        var next = el.nextSibling;
        var isSpacer = next && next.nodeType===1 && next.classList && next.classList.contains('spacer-20');
        if (!isSpacer){
          var d = doc.createElement('div');
          d.className = 'spacer-20';
          d.innerHTML = '&hairsp;';
          el.parentNode.insertBefore(d, next);
        }
      });
    });
    return c.innerHTML;
  }catch(e){
    return html;
  }
};


/* Import DOCX (marker-based)
  function addSpacersToContent(html){
    try{
      var doc = document.implementation.createHTMLDocument('spacers');
      var c = doc.createElement('div'); c.innerHTML = html;
      var blockSelectors = ['p','ul','ol','h1','h2','h3','h4','h5','h6','table','blockquote','pre','img','figure'];
      // Add spacer after each matching element (if not already directly followed by a spacer)
      blockSelectors.forEach(function(tag){
        Array.from(c.querySelectorAll(tag)).forEach(function(el){
          // skip empty paragraphs
          if (tag==='p' && !el.textContent.trim() && !el.querySelector('img,table,ul,ol')) return;
          var next = el.nextSibling;
          var isSpacer = next && next.nodeType===1 && next.classList && next.classList.contains('spacer-20');
          if (!isSpacer){
            var d = doc.createElement('div');
            d.className = 'spacer-20';
            d.innerHTML = '&hairsp;';
            el.parentNode.insertBefore(d, next);
          }
        });
      });
      return c.innerHTML;
    }catch(e){
      return html;
    }
  }
 → Primary/Secondary/Partner cards with Primary outline */
(function(){
  if (window.__docxImportBoundMarkers) return; window.__docxImportBoundMarkers = true;

  var preview = document.getElementById('preview') || document.body;
  var btn = document.getElementById('import-docx');
  var input = document.getElementById('docx-file');

  /* Keep anchors: header/hero/date/author, Subscribe CTA, Disclaimer, Dynamic */
  function keepBlock(block){
    var lbl  = (block && block.getAttribute && block.getAttribute('data-label')) || '';
    var type = (block && block.getAttribute && block.getAttribute('data-type')) || '';
    if (/header|hero banner|author banner|date bar/i.test(lbl)) return true;
    if (/subscribe cta line/i.test(lbl)) return true;
    if (/disclaimer/i.test(type) || /disclaimer/i.test(lbl)) return true;
    if (/dynamic content block/i.test(lbl)) return true;
    return false; // remove others (incl. partner) before import
  }
  function removeExistingCards(){
    Array.from(preview.querySelectorAll('.be-block')).forEach(function(b){
      if (!keepBlock(b)) b.remove();
    });
  }

  /* Primary-style scaffolds (outline + rounded corners + spacing) */
  function insertAtAnchor(wrap){
    var anchor = preview.querySelector('.be-block[data-label*="Subscribe CTA line"]')
        || preview.querySelector('.be-block[data-type="disclaimer"]')
        || Array.from(preview.querySelectorAll('.be-block')).find(function(b){
             var l = (b.dataset && b.dataset.label)||''; return /dynamic content block/i.test(l);
           });
    if (anchor && anchor.parentNode) anchor.parentNode.insertBefore(wrap, anchor);
    else preview.appendChild(wrap);
  }

  function primaryScaffold(innerHtml, idx){
  innerHtml = window.addSpacersToContent(innerHtml);

  innerHtml = addSpacersToContent(innerHtml);

    var wrap = document.createElement('div');
    wrap.className = 'be-block font-roboto';
    wrap.setAttribute('data-type','primary');
    wrap.setAttribute('data-label','Imported card ' + (idx+1));
    wrap.innerHTML =
      '<div class="be-label"><i class="dot"></i><span>Imported card ' + (idx+1) + '</span></div>' +
      '<div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>' +
      '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>' +
      '  <table cellpadding="0" cellspacing="0" class="container bg-white" role="presentation" width="685" style="border:2px solid #232021;border-radius:22px;">' +
      '    <tbody><tr><td class="px-25" style="padding:20px 25px 20px 25px;"><div class="font-sans fs-16" contenteditable="true">' + innerHtml + '</div></td></tr></tbody>' +
      '  </table>' +
      '</td></tr></tbody></table>' +
      '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>' +
      '  <table class="container" role="presentation" width="685"><tbody><tr><td><div class="spacer-20">&hairsp;</div></td></tr></tbody></table>' +
      '</td></tr></tbody></table>';
    insertAtAnchor(wrap);
  }

  

function secondaryScaffold(innerHtml, idx){
  // Ensure internal content elements have spacers
  innerHtml = window.addSpacersToContent ? window.addSpacersToContent(innerHtml) : innerHtml;

  var wrap = document.createElement('div');
  wrap.className = 'be-block font-roboto';
  wrap.setAttribute('data-type','secondary');
  wrap.setAttribute('data-label','Imported card ' + (idx+1));
  wrap.innerHTML =
    '<div class="be-label"><i class="dot"></i><span>Imported card ' + (idx+1) + '</span></div>'+
    '<div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>'+
    '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>'+
      '<table cellpadding="0" cellspacing="0" class="container bg-cream card" role="presentation" width="685">'+
        '<tbody>'+
          '<tr><td class="px-25 pt-20">'+ innerHtml +'</td></tr>'+
          '<tr><td class="px-25"><div class="spacer-20">&hairsp;</div></td></tr>'+
        '</tbody>'+
      '</table>'+
    '</td></tr></tbody></table>';

  // Insert the card at the correct anchor
  insertAtAnchor(wrap);

  // Add an external spacer row after the card, to mirror template spacing
  try {
    var spacerTable = document.createElement('table');
    spacerTable.setAttribute('cellpadding','0');
    spacerTable.setAttribute('cellspacing','0');
    spacerTable.setAttribute('role','presentation');
    spacerTable.setAttribute('width','100%');
    spacerTable.className = 'row';
    spacerTable.innerHTML =
      '<tbody><tr><td>'+
        '<table class="container" role="presentation" width="685">'+
          '<tbody><tr><td><div class="spacer-20">&hairsp;</div></td></tr></tbody>'+
        '</table>'+
      '</td></tr></tbody>';
    wrap.insertAdjacentElement('afterend', spacerTable);
  } catch(e){ /* no-op */ }
}



  function partnerScaffold(headerText, innerHtml, idx){
    var headerTable =
      '<table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="mso-table-lspace:0;mso-table-rspace:0;margin-left:auto;margin-right:auto;" width="100%">' +
      '<tbody><tr><td align="center">' +
      '<table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="width:685px;max-width:100%;background-color:#1d53ff;border:2px solid #232021;border-radius:22px 22px 0 0;margin-left:auto;margin-right:auto;" width="685">' +
      '<tbody><tr><td style="padding:20px 25px 10px 25px;">' +
      '<p style="margin:0;font-family:Helvetica,Arial,sans-serif;font-size:20px;line-height:1.2;color:#ffffff;"><strong>' + (headerText || 'From Our Partners') + '</strong></p>' +
      '</td></tr></tbody></table>' +
      '</td></tr></tbody></table>';

    var cardTable =
      '<table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="mso-table-lspace:0;mso-table-rspace:0;margin-left:auto;margin-right:auto;" width="100%">' +
      '<tbody><tr><td align="center">' +
      '<table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="width:685px;max-width:100%;background-color:#ffffff;border:2px solid #232021;border-top:0;border-radius:0 0 22px 22px;margin-left:auto;margin-right:auto;" width="685">' +
      '<tbody><tr><td align="left" style="padding:20px 25px 20px 25px;">' +
      '<div class="font-sans fs-16" contenteditable="true">' + innerHtml + '</div>' +
      '</td></tr></tbody></table>' +
      '</td></tr></tbody></table>';

    var wrap = document.createElement('div');
    wrap.className = 'be-block font-roboto';
    wrap.setAttribute('data-type','partner-card');
    wrap.setAttribute('data-label','Imported partner ' + (idx+1));
    wrap.innerHTML =
      '<div class="be-label"><i class="dot"></i><span>Imported partner ' + (idx+1) + '</span></div>' +
      '<div class="be-block-toolbar"><button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button></div>' +
      headerTable + cardTable +
      '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>' +
      '  <table class="container" role="presentation" width="685"><tbody><tr><td><div class="spacer-20">&hairsp;</div></td></tr></tbody></table>' +
      '</td></tr></tbody></table>';
    insertAtAnchor(wrap);
  }

  /* Sanitize Mammoth HTML to an email-safe subset */
  var ALLOWED = new Set(['A','STRONG','EM','U','BR','P','UL','OL','LI','H2','H3','SPAN','B','I']);
  var INLINE_OK = new Set(['font-weight','font-style','text-decoration']);

  function normalizeInline(el){
    var fw=(el.style&&(el.style.fontWeight||'')+'').toLowerCase();
    var fs=(el.style&&(el.style.fontStyle||'')+'').toLowerCase();
    var td=(el.style&&(el.style.textDecoration||'')+'').toLowerCase();
    var wrap=el; function wrapWith(tag){var w=el.ownerDocument.createElement(tag);while(wrap.firstChild) w.appendChild(wrap.firstChild); if (wrap.parentNode) wrap.parentNode.replaceChild(w, wrap); wrap=w;}
    if (fw==='bold'||fw==='700'||fw==='600'||fw==='800'||fw==='900'){ wrapWith('strong'); }
    if (fs==='italic'){ wrapWith('em'); }
    if (td.indexOf('underline')!==-1){ wrapWith('u'); }
    if (wrap.removeAttribute) wrap.removeAttribute('style');
    return wrap;
  }
  function sanitizeNode(node, doc){
    if (node.nodeType===3) return doc.createTextNode(node.nodeValue);
    if (node.nodeType!==1) return doc.createDocumentFragment();
    var tag=node.tagName.toUpperCase();
    if (!ALLOWED.has(tag)){
      var frag=doc.createDocumentFragment(); node.childNodes.forEach(function(ch){ frag.appendChild(sanitizeNode(ch,doc)); }); return frag;
    }
    var out=doc.createElement(tag);
    if (tag==='A'){
      var href=node.getAttribute('href')||''; if (/^(https?:|mailto:)/i.test(href)){ out.setAttribute('href',href); out.setAttribute('target','_blank'); out.setAttribute('rel','noopener'); }
    } else if (tag==='SPAN' || tag==='B' || tag==='I'){
      var kept=[], style=node.getAttribute('style')||''; style.split(';').forEach(function(r){ var kv=r.split(':'); if (kv.length===2){ var k=kv[0].trim().toLowerCase(), v=kv[1].trim(); if (INLINE_OK.has(k)) kept.push(k+':'+v); } });
      if (kept.length) out.setAttribute('style', kept.join(';'));
    }
    node.childNodes.forEach(function(ch){ out.appendChild(sanitizeNode(ch,doc)); });
    if (out.tagName==='SPAN' && out.hasAttribute('style')) out=normalizeInline(out);
    if (out.tagName==='B'){ var s=doc.createElement('strong'); while(out.firstChild) s.appendChild(out.firstChild); out=s; }
    if (out.tagName==='I'){ var e=doc.createElement('em'); while(out.firstChild) e.appendChild(out.firstChild); out=e; }
    if (out.removeAttribute){ out.removeAttribute('id'); out.removeAttribute('class'); }
    return out;
  }
  function sanitizeHtml(html){
    var doc=document.implementation.createHTMLDocument('docx');
    var c=doc.createElement('div'); c.innerHTML=html;
    // Unwrap <p><hr></p> into standalone <hr>
    c.querySelectorAll('p').forEach(function(p){ var hr=p.querySelector('hr'); if (hr){ p.parentNode.insertBefore(hr,p); if(!p.textContent.trim()) p.remove(); } });
    // Convert paragraphs of only ---/***/___/—— into <hr>
    c.querySelectorAll('p').forEach(function(p){ var t=(p.textContent||'').trim(); if (/^(?:-{3,}|\*{3,}|_{3,}|\u2014{2,})$/.test(t)){ var hr=doc.createElement('hr'); p.parentNode.insertBefore(hr,p); p.remove(); } });

    // Sanitize into array (single chunk, we split later with markers)
    var out=[], fdoc=document.implementation.createHTMLDocument('frag'), frag=fdoc.createDocumentFragment();
    Array.from(c.childNodes).forEach(function(n){ frag.appendChild(sanitizeNode(n,fdoc)); });
    var tmp=fdoc.createElement('div'); tmp.appendChild(frag);
    out.push(tmp.innerHTML);
    return out;
  }

  /* Marker-based segmentation */
  function parseSegmentsWithMarkers(html){
    var doc=document.implementation.createHTMLDocument('docx-markers');
    var container=doc.createElement('div'); container.innerHTML=html;

    var partnerHeaderText='';
    container.querySelectorAll('*').forEach(function(el){
      if (el.innerHTML && el.innerHTML.indexOf('{{ partner-header }}')!==-1){
        partnerHeaderText = el.textContent.replace('{{ partner-header }}','').trim();
        el.innerHTML = el.innerHTML.replace('{{ partner-header }}','');
      }
    });

    ['primary','secondary','partner'].forEach(function(kind){
      var re=new RegExp('\\{\\{\\s*end-'+kind+'\\s*\\}\\}','gi');
      container.innerHTML = container.innerHTML.replace(re, '<hr data-marker="end-'+kind+'">');
    });

    var segments=[], buf=doc.createElement('div');
    function push(kind){
      var html=buf.innerHTML.trim();
      if (html.replace(/<[^>]+>/g,'').trim().length===0){ buf.innerHTML=''; return; }
      segments.push({kind:kind, html:html}); buf.innerHTML='';
    }
    Array.from(container.childNodes).forEach(function(n){
      if (n.nodeType===1 && n.tagName.toUpperCase()==='HR' && n.hasAttribute('data-marker')){
        var mk=n.getAttribute('data-marker');
        if (mk==='end-primary') push('primary');
        else if (mk==='end-secondary') push('secondary');
        else if (mk==='end-partner') push('partner');
      } else {
        buf.appendChild(n.cloneNode(true));
      }
    });
    if (buf.innerHTML.trim().length){ push('primary'); } // default trailing chunk
    return {segments:segments, partnerHeaderText:partnerHeaderText};
  }

  async function docxToHtml(file){
    if (!window.mammoth) throw new Error('Mammoth.js not loaded');
    var array = await file.arrayBuffer();
    var res = await window.mammoth.convertToHtml({arrayBuffer: array}, {
      styleMap:[ "b => strong", "i => em", "u => u", "p[style-name='Heading 2'] => h2", "p[style-name='Heading 3'] => h3" ]
    });
    return res.value || "";
  }

  async function handleFile(file){
    /* Safe partner purge (minimal) */
    (function(){
      try{
        var root = document.getElementById('preview') || document.getElementById('nl-container') || document.body;
        if (!root) return;
        root.querySelectorAll('[data-type="partner-header"], [data-type="partner-card"]').forEach(function(n){ n.remove(); });
        Array.prototype.forEach.call(root.querySelectorAll('.be-block[data-label]'), function(n){
          var lbl = (n.getAttribute('data-label')||'').toLowerCase();
          if (lbl.indexOf('partner') !== -1) n.remove();
        });
      }catch(e){ /* no-op */ }
    })();

    try{
      var raw = await docxToHtml(file);
      var parts = sanitizeHtml(raw);
      var parsed = parseSegmentsWithMarkers(parts.join("\n"));
      removeExistingCards();
      var count=0;
      parsed.segments.forEach(function(seg){
        if (seg.kind==='primary')   primaryScaffold(seg.html, count++);
        else if (seg.kind==='secondary') secondaryScaffold(seg.html, count++);
        else if (seg.kind==='partner')   partnerScaffold(parsed.partnerHeaderText, seg.html, count++);
      });
      if (typeof window.__updateBeCount==='function') window.__updateBeCount();
      if (typeof showToast==='function') showToast('Imported ' + count + ' card(s) from DOCX');
    }catch(e){
      alert('DOCX import failed: ' + (e && e.message?e.message:e));
    }
  }

  if (btn && input){
    btn.addEventListener('click', function(e){ e.preventDefault(); input.click(); });
    input.addEventListener('change', function(){
      var f = input.files && input.files[0];
      if (f) handleFile(f);
      input.value='';
    });
  }
})();
</script><div id="export-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:99998;"><div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;width:min(900px,90vw);max-height:80vh;overflow:auto;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px;"><div style="font:600 16px/1.2 system-ui,Segoe UI,Arial,sans-serif;margin-bottom:8px;">Export HTML</div><pre id="export-code" style="background:#111;color:#fff;padding:12px;border-radius:8px;white-space:pre-wrap;word-break:break-word;max-height:56vh;overflow:auto;"></pre><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;"><button id="export-copy" style="padding:8px 12px;border:1px solid #005bfb;border-radius:8px;background:#005bfb;color:#fff;cursor:pointer;">Copy email HTML</button><button id="export-close" style="padding:8px 12px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer;">Close</button></div></div></div><div id="be-toast" style="position:fixed;z-index:99999;bottom:16px;right:16px;background:#232021;color:#fff;padding:10px 12px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.25);font:500 13px/1.3 system-ui,Segoe UI,Arial,sans-serif;opacity:0;transition:opacity .2s;">Copied to clipboard</div><script>
(function(){
  if (window.__exportBoundStable) return; window.__exportBoundStable = true;

  function showToast(msg){
    var t=document.getElementById('be-toast'); if(!t) return;
    t.textContent = msg||'Copied to clipboard';
    t.style.opacity = '1';
    setTimeout(function(){ t.style.opacity = '0'; }, 1200);
  }

  function buildHead(){
    return '' +
      '<title></title>' +
      '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' +
      '<meta name="viewport" content="width=device-width,initial-scale=1">' +
      '<!--[if mso]><xml><w:WordDocument xmlns:w=\"urn:schemas-microsoft-com:office:word\"><w:DontUseAdvancedTypographyReadingMail/></w:WordDocument><o:OfficeDocumentSettings><o:PixelsPerInch>96</o:PixelsPerInch><o:AllowPNG/></o:OfficeDocumentSettings></xml><![endif]-->' +
      '<!--[if !mso]><link href=\"https://fonts.googleapis.com/css?family=Roboto\" rel=\"stylesheet\" type=\"text/css\"><![endif]-->';
  }

  function cloneForExport(){
    var root = document.querySelector('#nl-container') || document.querySelector('#preview') || document.body;
    var clone = root.cloneNode(true);

    // Remove editor chrome
    clone.querySelectorAll('.main-header, .be-header, .be-info, #editor-actions, .be-label, .be-block-toolbar').forEach(function(el){ el.remove(); });
    // Remove export modal and any scripts
    var modal = clone.querySelector('#export-modal'); if (modal) modal.remove();
    clone.querySelectorAll('script').forEach(function(el){ el.remove(); });
    // Remove preview-only artifacts
    clone.querySelectorAll('.be-clip, #be-toast').forEach(function(el){ el.remove(); });
    // Strip contenteditable and be-* classes
    clone.querySelectorAll('[contenteditable]').forEach(function(el){ el.removeAttribute('contenteditable'); });
    clone.querySelectorAll('[class]').forEach(function(el){
      el.className = el.className.replace(/\bbe-\w+\b/g,'').trim();
      if (!el.className) el.removeAttribute('class');
    });
    // Center presentation tables
    clone.querySelectorAll('table[role="presentation"], table.container').forEach(function(tb){
      tb.setAttribute('align','center');
      var st = tb.getAttribute('style')||'';
      if (st.indexOf('margin-left:auto')===-1) st += (st?';':'') + 'margin-left:auto;margin-right:auto;';
      tb.setAttribute('style', st);
    });

    return clone.innerHTML.trim();
  }

  function buildExportHtml(bodyInner){
    return '<!doctype html><html><head>' + buildHead() + '</head><body>' + bodyInner + '</body></html>';
  }

  function openExport(){
    var modal = document.getElementById('export-modal');
    var code  = document.getElementById('export-code');
    if (!modal || !code) return;
    code.textContent = buildExportHtml(cloneForExport());
    modal.style.display = 'block';
  }

  function closeExport(){
    var modal = document.getElementById('export-modal');
    if (modal) modal.style.display = 'none';
  }

  // Bindings (non-capturing, direct)
  var openBtn = document.getElementById('be-export');
  if (openBtn) openBtn.addEventListener('click', function(e){ e.preventDefault(); openExport(); });
  var closeBtn = document.getElementById('export-close');
  if (closeBtn) closeBtn.addEventListener('click', function(){ closeExport(); });
  var copyBtn = document.getElementById('export-copy');
  if (copyBtn) copyBtn.addEventListener('click', function(){
    var html = buildExportHtml(cloneForExport());
    navigator.clipboard.writeText(html).then(function(){ showToast('Export HTML copied'); });
  });

  // Mirror behavior for #be-copy if present (copy without opening modal)
  var copyHdr = document.getElementById('be-copy');
  if (copyHdr) copyHdr.addEventListener('click', function(){
    var html = buildExportHtml(cloneForExport());
    navigator.clipboard.writeText(html).then(function(){ showToast('Export HTML copied'); });
  });
})();
</script><script>
(function(){
  var r = document.getElementById('be-reset');
  if (!r) return;
  r.addEventListener('click', function(ev){
    ev.preventDefault();
    ev.stopPropagation();
    try { location.reload(); } catch(e){ console && console.warn('Reload failed', e); }
  }, false);
})();
</script><script>
(function(){
  // Hard reset bindings by replacing the button as well (drops legacy listeners)
  var btn = document.getElementById('import-docx');
  if (!btn) return;
  var parent = btn.parentNode;
  var cloneBtn = btn.cloneNode(true);
  // Preserve id/class/style/text
  parent.replaceChild(cloneBtn, btn);
  btn = cloneBtn;

  var inp = document.getElementById('docx-file');
  if (!inp) return;

  // Guard to ensure we only ever bind once
  if (btn.__importBoundOnce) return;
  btn.__importBoundOnce = true;

  function toast(msg){
    var t=document.getElementById('be-toast');
    if (t){ t.textContent = msg; t.style.opacity='1'; setTimeout(function(){ t.style.opacity='0'; }, 1400); }
    else { try { console.log(msg); } catch(e){} }
  }

  btn.onclick = function(ev){
    ev.preventDefault(); ev.stopPropagation();
    // prevent accidental double trigger if inside a label or nested element
    setTimeout(function(){ inp.click(); }, 0);
  };

  inp.onchange = async function(){
    var f = inp.files && inp.files[0];
    if (!f){ return; } // silent cancel
    try{
      if (typeof handleFile !== 'function') throw new Error('Importer not initialized');
      await handleFile(f);
      toast('Imported: ' + (f.name || 'document'));
    }catch(err){
      console.error(err);
      toast('Import failed: ' + (err && err.message ? err.message : err));
    }finally{
      // Allow selecting the same file again
      inp.value = '';
    }
  };
})();
</script><script>
/* Fallback importer (safe no-op if main importer exists) */
(function(){
  if (typeof handleFile === 'function') return;
  async function docxToHtml(file){
    if (window.ensureMammoth) { try { await window.ensureMammoth(); } catch(e){} }
    if (window.mammoth){
      const buf = await file.arrayBuffer();
      const res = await mammoth.convertToHtml({arrayBuffer: buf});
      return '<div>' + (res && res.value ? res.value : '') + '</div>';
    } else {
      throw new Error('Mammoth not available; try HTML import');
    }
  }
  window.handleFile = async function(file){
    var name = (file && file.name || '').toLowerCase();
    var htmlRaw;
    if (name.endsWith('.html') || name.endsWith('.htm') || file.type === 'text/html'){
      htmlRaw = await file.text();
    } else if (name.endsWith('.txt') || file.type === 'text/plain'){
      htmlRaw = await file.text();
      htmlRaw = htmlRaw.replace(/^[ \t]*-{3,}[ \t]*$/gm, '<hr data-marker="end-primary">');
      htmlRaw = htmlRaw.replace(/\n{2,}/g, '</p><p>').replace(/\n/g, '<br>');
      htmlRaw = '<div><p>' + htmlRaw + '</p></div>';
    } else {
      htmlRaw = await docxToHtml(file);
    }
    // Minimal insertion: append a single primary card with the imported HTML (for debugging pipeline)
    var root = document.getElementById('nl-container') || document.getElementById('preview') || document.body;
    var wrapper = document.createElement('div');
    wrapper.className = 'be-block';
    wrapper.setAttribute('data-type','primary');
    wrapper.setAttribute('data-label','Imported (debug)');
    wrapper.innerHTML = ''
      + '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%">'
      + '<tbody><tr><td>'
      + '<table cellpadding="0" cellspacing="0" class="container bg-white card" role="presentation" width="685">'
      + '<tbody><tr><td class="px-25 py-20 font-sans fs-16 text-dark"></td></tr></tbody></table>'
      + '</td></tr></tbody></table>';
    wrapper.querySelector('td.px-25').innerHTML = htmlRaw;
    root.appendChild(wrapper);
    var t=document.getElementById('be-toast'); if(t){ t.textContent='Imported (fallback)'; t.style.opacity='1'; setTimeout(function(){ t.style.opacity='0'; }, 1200); }
  };
})();
</script><script>
(function(){
  var btn = document.getElementById('import-docx');
  var inp = document.getElementById('docx-file');
  if (!btn || !inp) return;
  btn.onclick = function(ev){ ev.preventDefault(); ev.stopPropagation(); setTimeout(function(){ inp.click(); }, 0); };
  inp.onchange = async function(){
    var f = inp.files && inp.files[0];
    if(!f){ return; }
    try{
      if (typeof handleFile !== 'function') throw new Error('handleFile missing');
      await handleFile(f);
    }catch(e){
      var t=document.getElementById('be-toast'); if(t){ t.textContent='Import failed: '+(e.message||e); t.style.opacity='1'; setTimeout(function(){ t.style.opacity='0'; }, 1600); }
    }finally{
      inp.value='';
    }
  };
})();
</script><script>
(function(){
  // Debug panel
  function toast(msg){
    try{
      var t=document.getElementById('be-toast');
      if(t){ t.textContent=String(msg); t.style.opacity='1'; setTimeout(function(){ t.style.opacity='0'; }, 1600); }
      else { console.log(msg); }
    }catch(e){}
  }
  async function docxToHtml(file){
    await (window.ensureMammoth ? window.ensureMammoth() : Promise.resolve());
    if (!window.mammoth) throw new Error('Mammoth not available');
    const buf = await file.arrayBuffer();
    const res = await mammoth.convertToHtml({arrayBuffer: buf});
    return '<div>' + (res && res.value ? res.value : '') + '</div>';
  }
  window.handleFile = async function(file){
    // Basic, guaranteed pipeline: convert to HTML string
    var name = (file && file.name || '').toLowerCase();
    var htmlRaw;
    if (name.endsWith('.html') || name.endsWith('.htm') || file.type === 'text/html'){
      htmlRaw = await file.text();
    } else if (name.endsWith('.txt') || file.type === 'text/plain'){
      htmlRaw = await file.text();
      htmlRaw = htmlRaw.replace(/^[ \t]*-{3,}[ \t]*$/gm, '<hr data-marker="end-primary">');
      htmlRaw = htmlRaw.replace(/\n{2,}/g, '</p><p>').replace(/\n/g, '<br>');
      htmlRaw = '<div><p>' + htmlRaw + '</p></div>';
    } else {
      htmlRaw = await docxToHtml(file);
    }

    // Remove partner blocks before import
    try{
      var root = document.getElementById('nl-container') || document.getElementById('preview') || document.body;
      root.querySelectorAll('[data-type="partner-header"], [data-type="partner-card"]').forEach(function(n){ n.remove(); });
      root.querySelectorAll('[data-label]').forEach(function(n){
        var t=(n.getAttribute('data-label')||'').toLowerCase();
        if (t.indexOf('partner')!==-1) n.remove();
      });
    }catch(e){}

    // Split by HR or marker into chunks (very simple)
    var container = document.createElement('div');
    container.innerHTML = htmlRaw;
    var parts = [];
    var current = document.createElement('div');
    function pushCurrent(){
      if (current && current.innerHTML.trim()) parts.push(current);
      current = document.createElement('div');
    }
    Array.from(container.childNodes).forEach(function(node){
      if (node.nodeType===1 && node.tagName==='HR'){ pushCurrent(); }
      else current.appendChild(node.cloneNode(true));
    });
    pushCurrent();
    if (!parts.length){ parts = [container]; }

    // Where to insert: above Subscribe CTA if present; else above Disclaimer; else above Dynamic block; else append
    var root = document.getElementById('nl-container') || document.getElementById('preview') || document.body;
    var anchors = Array.from(root.querySelectorAll('[data-label]'));
    function findByLabel(substr){
      return anchors.find(function(n){ return ((n.getAttribute('data-label')||'').toLowerCase().indexOf(substr)>=0); });
    }
    var beforeNode = findByLabel('subscribe cta line') || findByLabel('disclaimer') || findByLabel('dynamic content block');
    var mount = beforeNode ? beforeNode : null;

    // Build primary-styled cards and insert
    parts.forEach(function(part, idx){
      var wrap = document.createElement('div');
      wrap.className = 'be-block';
      wrap.setAttribute('data-type','primary');
      wrap.setAttribute('data-label', 'Imported card');
      wrap.innerHTML = ''
        + '<table cellpadding="0" cellspacing="0" class="row" role="presentation" width="100%"><tbody><tr><td>'
        +   '<table cellpadding="0" cellspacing="0" class="container bg-white card" role="presentation" width="685">'
        +     '<tbody><tr><td class="px-25 py-20 font-sans fs-16 text-dark"></td></tr></tbody>'
        +   '</table>'
        + '</td></tr></tbody></table>';
      wrap.querySelector('td.px-25').innerHTML = part.innerHTML;
      if (mount && mount.parentNode){
        mount.parentNode.insertBefore(wrap, mount);
      } else {
        root.appendChild(wrap);
      }
    });

    toast('Imported ' + parts.length + ' card(s)');
  };

  // Single binding for button/input
  var btn = document.getElementById('import-docx');
  var inp = document.getElementById('docx-file');
  if (btn && inp){
    btn.onclick = function(ev){ ev.preventDefault(); ev.stopPropagation(); setTimeout(function(){ inp.click(); },0); };
    inp.onchange = function(){
      var f = inp.files && inp.files[0];
      if (!f) return;
      handleFile(f).catch(function(e){ toast('Import failed: ' + (e.message||e)); });
      inp.value='';
    };
  }
})();</script></body>
</html>
</div>
<div class="be-clip">Preview stops here. Sections below remain in the copied HTML.</div>
</div>
<div aria-label="Formatting" class="be-toolbar" id="be-toolbar" role="toolbar">
<button data-cmd="bold"><strong>B</strong></button>
<button data-cmd="italic"><em>I</em></button>
<button data-cmd="underline"><u>U</u></button>
<span class="be-sep"></span>
<button data-cmd="insertUnorderedList">• List</button>
<button data-cmd="insertOrderedList">1. List</button>
<span class="be-sep"></span>
<button data-cmd="formatBlock" data-value="H2">H2</button>
<button data-cmd="formatBlock" data-value="H3">H3</button>
<span class="be-sep"></span>
<button id="be-link">Link</button>
<button id="be-clear">Clear</button>
</div>
<script>
const RAW_STYLES = ``;
const TRAIL_HTML = ``;

// Inject template styles into <head>
(function(){ if (RAW_STYLES && !document.getElementById('braze-email-styles')){ const d=document.createElement('div'); d.id='braze-email-styles'; d.innerHTML=RAW_STYLES; [...d.childNodes].forEach(n=>document.head.appendChild(n)); } })();

const preview = document.getElementById('preview');
preview.setAttribute('contenteditable','true');

function nextTableAfter(node) {
  let probe = node.nextSibling, hops=0;
  while (probe && hops < 80) {
    if (probe.nodeType === 1 && probe.tagName === 'TABLE') return probe;
    if (probe.nodeType === 1) { const t = probe.querySelector('table'); if (t) return t; }
    probe = probe.nextSibling; hops++;
  }
  return null;
}

// Group Rows 1–4 into one locked header block
(function groupHeader(){
  const walker = document.createTreeWalker(preview, NodeFilter.SHOW_COMMENT, null);
  const labels = []; let n; while(n = walker.nextNode()) labels.push(n);
  const row1 = labels.find(c => /^\\s*Row\\s*1\\b/i.test(c.data||''));
  const row4 = labels.find(c => /^\\s*Row\\s*4\\b/i.test(c.data||''));
  if (!row1 || !row4) return;
  const firstTable = nextTableAfter(row1);
  const lastTable = nextTableAfter(row4);
  if (!firstTable || !lastTable) return;
  const wrap = document.createElement('div');
  wrap.className='be-block'; wrap.dataset.type='locked'; wrap.dataset.label='Header (Rows 1–4)';
  const lbl = document.createElement('div'); lbl.className='be-label'; lbl.innerHTML='<i class="dot"></i><span>Header (Rows 1–4)</span>';
  const tools = document.createElement('div'); tools.className='be-block-toolbar'; tools.innerHTML='<button class="be-ico be-handle" disabled>⋮⋮</button><button class="be-ico" disabled>Copy</button><button class="be-ico" disabled>Delete</button>';
  wrap.appendChild(lbl); wrap.appendChild(tools);
  firstTable.parentNode.insertBefore(wrap, firstTable);
  let cur = firstTable;
  while (cur) { const nx = cur.nextSibling; wrap.appendChild(cur); if (cur === lastTable) break; cur = nx; }
})();

// Wrap remaining blocks, skipping spacers (append to previous block); infer type
(function wrapBlocks(){
  const walker = document.createTreeWalker(preview, NodeFilter.SHOW_COMMENT, null);
  const comments = []; let n; while(n = walker.nextNode()) comments.push(n);
  const blocks = [];
  function isSpacer(label){ return /spacer/i.test(label) && !/story|card/i.test(label); }
  comments.forEach(c => {
    const label = (c.data||'').trim();
    if (!label || /^\\s*Row\\s*(1|2|3|4)\\b/i.test(label)) return;
    if (/Were you forwarded this email/i.test(label)) return;
    const table = nextTableAfter(c);
    if (!table) return;

    if (isSpacer(label)) { const prev = blocks[blocks.length-1]; if (prev) prev.appendChild(table); return; }

    let type='primary';
    if (/from our partners/i.test(label) && /header/i.test(label)) type='partner-header';
    else if (/from our partners/i.test(label)) type='partner-card';
    else if (/today's stories|secondary|beige/i.test(label)) type='secondary';

    const wrap = document.createElement('div'); wrap.className='be-block'; wrap.dataset.type=type; wrap.dataset.label=label;
    const lbl = document.createElement('div'); lbl.className='be-label'; lbl.innerHTML='<i class="dot"></i><span>'+label+'</span>';
    const tools = document.createElement('div'); tools.className='be-block-toolbar'; tools.innerHTML='<button class="be-ico be-handle">⋮⋮</button><button class="be-ico" data-act="dup">Copy</button><button class="be-ico" data-act="del">Delete</button>';
    wrap.appendChild(lbl); wrap.appendChild(tools);
    table.parentNode.insertBefore(wrap, table);
    wrap.appendChild(table);
    blocks.push(wrap);
  });
  document.getElementById('be-count').textContent = preview.querySelectorAll('.be-block').length + ' blocks';
})();

// ===== Mouse-based sortable (works in Chrome with contenteditable) =====
(function enableMouseSort(){
  let dragging = null;
  let startY = 0;
  let ghost = null;
  const placeholder = document.createElement('div'); placeholder.className = 'be-placeholder';

  function blocks(){ return [...preview.querySelectorAll('.be-block')]; }

  function onMouseMove(e){
    if(!dragging || !ghost) return;
    ghost.style.top = (e.clientY + 8) + 'px';
    ghost.style.left = (e.clientX + 8) + 'px';

    // Decide placeholder position
    const candidates = blocks().filter(b => b !== dragging);
    let best = null, bestDist = Infinity;
    const y = e.clientY;
    for(const c of candidates){
      const r = c.getBoundingClientRect();
      const mid = r.top + r.height/2;
      const dist = Math.abs(y - mid);
      if (dist < bestDist){ bestDist = dist; best = {el:c, before: y < mid}; }
    }
    if (best){
      const ref = best.el;
      if (best.before){
        if (placeholder !== ref.previousSibling) ref.parentNode.insertBefore(placeholder, ref);
      } else {
        if (placeholder !== ref.nextSibling) ref.parentNode.insertBefore(placeholder, ref.nextSibling);
      }
    } else {
      preview.appendChild(placeholder);
    }
  }

  function endDrag(){
    if(!dragging) return;
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', endDrag);
    if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
    ghost = null;
    dragging.classList.remove('dragging');
    if (placeholder.parentNode) placeholder.parentNode.insertBefore(dragging, placeholder);
    if (placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
    dragging = null;
    const badge = document.getElementById('be-count'); if (badge) badge.textContent = blocks().length + ' blocks';
  }

  preview.addEventListener('mousedown', (e)=>{
    const h = e.target.closest('.be-handle'); if (!h) return;
    const b = h.closest('.be-block'); if (!b || b.dataset.type==='locked') return;
    e.preventDefault(); // don't select text
    dragging = b;
    startY = e.clientY;
    dragging.classList.add('dragging');

    // Create ghost
    const r = b.getBoundingClientRect();
    ghost = document.createElement('div');
    ghost.className = 'be-ghost';
    ghost.style.width = r.width + 'px';
    ghost.style.height = r.height + 'px';
    ghost.style.top = (e.clientY + 8) + 'px';
    ghost.style.left = (e.clientX + 8) + 'px';
    const inner = document.createElement('div');
    inner.className = 'be-ghost-inner';
    inner.innerHTML = b.innerHTML;
    ghost.appendChild(inner);
    document.body.appendChild(ghost);

    // Insert placeholder after the block initially
    b.parentNode.insertBefore(placeholder, b.nextSibling);

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', endDrag);
  });

  // Buttons
  preview.addEventListener('click', e=>{
    const btn = e.target.closest('.be-ico'); if(!btn) return;
    const block = btn.closest('.be-block'); if(!block) return;
    if (block.dataset.type==='locked') return;
    if (btn.dataset.act==='del') block.remove();
    if (btn.dataset.act==='dup') block.parentNode.insertBefore(block.cloneNode(true), block.nextSibling);
    const badge = document.getElementById('be-count'); if (badge) badge.textContent = blocks().length + ' blocks';
  });

  // Rebind not needed; handlers are delegation-based
})();

// Add buttons clone first seen templates
(function addButtons(){
  function template(sel){ const n = preview.querySelector(sel); return n ? n.cloneNode(true) : null; }
  document.getElementById('add-primary').addEventListener('click', ()=>{ const t=template('.be-block[data-type="primary"]'); if(t) preview.appendChild(t); });
  document.getElementById('add-secondary').addEventListener('click', ()=>{ const t=template('.be-block[data-type="secondary"]'); if(t) preview.appendChild(t); });
  document.getElementById('add-partner').addEventListener('click', ()=>{ const h=template('.be-block[data-type="partner-header"]'); const c=template('.be-block[data-type="partner-card"]'); if(h) preview.appendChild(h); if(c) preview.appendChild(c); });
})();

// Inline formatting toolbar + clean paste
const toolbar = document.getElementById('be-toolbar');
function showToolbarAtSelection(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const r = sel.getRangeAt(0).getBoundingClientRect();
  if (!r) return;
  toolbar.style.display = 'block';
  toolbar.style.left = (r.left + r.width/2 + window.scrollX) + 'px';
  toolbar.style.top  = (r.top + window.scrollY - 8) + 'px';
}
preview.addEventListener('mouseup', showToolbarAtSelection);
preview.addEventListener('keyup', showToolbarAtSelection);
window.addEventListener('scroll', () => { if (toolbar.style.display==='block') showToolbarAtSelection(); }, { passive: true });

toolbar.addEventListener('click', (e)=>{
  const btn = e.target.closest('button'); if(!btn) return;
  const cmd = btn.dataset.cmd;
  if (cmd === 'formatBlock') document.execCommand('formatBlock', false, btn.dataset.value);
  else if (cmd) document.execCommand(cmd, false, null);
});
document.getElementById('be-link').addEventListener('click', ()=>{ const url = prompt('Link URL:'); if(!url) return; document.execCommand('createLink', false, url); });
document.getElementById('be-clear').addEventListener('click', ()=>{ document.execCommand('removeFormat', false, null); const sel=window.getSelection(); if(sel && sel.anchorNode){ const a= sel.anchorNode.parentElement && sel.anchorNode.parentElement.closest('a'); if(a){ const t=document.createTextNode(a.textContent); a.parentNode.replaceChild(t,a); } } });

// Clean paste
const cleanToggle = document.getElementById('be-clean-paste');
preview.addEventListener('paste', (e)=>{
  if (!cleanToggle.checked) return;
  const html = (e.clipboardData && e.clipboardData.getData('text/html')) || '';
  if (!html) return;
  e.preventDefault();
  const cleaned = (function stripFonts(html){
    const doc=new DOMParser().parseFromString('<div id=rt>'+html+'</div>','text/html');
    const root=doc.getElementById('rt');
    (function walk(n){
      if(n.nodeType===1){
        if(n.getAttribute('style')){
          let s=n.getAttribute('style').replace(/font-family\\s*:\\s*[^;]+;?/gi,'').replace(/font\\s*:\\s*[^;]+;?/gi,''); 
          s=s.replace(/;;+/g,';').replace(/\\s{2,}/g,' ').trim(); 
          if(s==='') n.removeAttribute('style'); else n.setAttribute('style',s);
        }
        if(n.tagName==='FONT'){ const span=doc.createElement('span'); const color=n.getAttribute('color'); if(color) span.style.color=color; while(n.firstChild) span.appendChild(n.firstChild); n.parentNode.replaceChild(span,n); }
        else if(n.hasAttribute('face')) n.removeAttribute('face');
      }
      let c=n.firstChild; while(c){ const nx=c.nextSibling; walk(c); c=nx; }
    })(root);
    return root.innerHTML;
  })(html);
  document.execCommand('insertHTML', false, cleaned);
});

// Copy/export full email HTML (styles + edited preview + trail)
document.getElementById('be-copy').addEventListener('click', async ()=>{
  const out = `` + "\\n" + preview.innerHTML + "\\n" + ``;
  try { await navigator.clipboard.writeText(out); alert('✅ Email HTML copied. Paste into Braze.'); }
  catch(e) { const blob=new Blob([out],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='email-for-braze.html'; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove(); alert('Clipboard blocked — downloaded the HTML instead.'); }
});

document.getElementById('be-reset').addEventListener('click', ()=>location.reload());
</script>
